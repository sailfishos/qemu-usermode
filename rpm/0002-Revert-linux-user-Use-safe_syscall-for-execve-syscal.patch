From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Frajo Haider <f_haider@gmx.at>
Date: Wed, 22 Jan 2020 10:48:18 +0200
Subject: [PATCH] Revert "linux-user: Use safe_syscall for execve syscall"

This reverts commit ffdcbe223d23461669869e85786145cce65e1e8c.
---
 linux-user/syscall.c | 15 ++-------------
 1 file changed, 2 insertions(+), 13 deletions(-)

diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 41ff4f05b9093d365eb3a0dd358ae8ba224fe1a1..7040f0f8729b2718852610e2101b33f8f528fb57 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -706,7 +706,6 @@ safe_syscall4(pid_t, wait4, pid_t, pid, int *, status, int, options, \
 #endif
 safe_syscall5(int, waitid, idtype_t, idtype, id_t, id, siginfo_t *, infop, \
               int, options, struct rusage *, rusage)
-safe_syscall3(int, execve, const char *, filename, char **, argv, char **, envp)
 #if defined(TARGET_NR_select) || defined(TARGET_NR__newselect) || \
     defined(TARGET_NR_pselect6) || defined(TARGET_NR_pselect6_time64)
 safe_syscall6(int, pselect6, int, nfds, fd_set *, readfds, fd_set *, writefds, \
@@ -8938,20 +8937,10 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
 
             if (!(p = lock_user_string(arg1)))
                 goto execve_efault;
-            /* Although execve() is not an interruptible syscall it is
-             * a special case where we must use the safe_syscall wrapper:
-             * if we allow a signal to happen before we make the host
-             * syscall then we will 'lose' it, because at the point of
-             * execve the process leaves QEMU's control. So we use the
-             * safe syscall wrapper to ensure that we either take the
-             * signal as a guest signal, or else it does not happen
-             * before the execve completes and makes it the other
-             * program's problem.
-             */
             if (is_proc_myself(p, "exe")) {
-                ret = get_errno(safe_execve(exec_path, argp, envp));
+                ret = get_errno(execve(exec_path, argp, envp));
             } else {
-                ret = get_errno(safe_execve(p, argp, envp));
+                ret = get_errno(execve(p, argp, envp));
             }
             unlock_user(p, arg1, 0);
 
